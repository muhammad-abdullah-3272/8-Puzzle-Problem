# 8 Puzzle Solver Using Manhattan Distance and Misplaced Tiles Heuristics
An interactive C++ implementation of the classic **8 Puzzle problem** using two heuristic search algorithms: **Manhattan Distance** and **Misplaced Tiles**. The code provides an efficient and interactive way to solve the 8 Puzzle problem for any valid configuration.

---

## Table of Contents
1. [Overview](#overview)
2. [How It Works](#how-it-works)
   - [Understanding the 8 Puzzle](#understanding-the-8-puzzle)
   - [Problem Solvability](#problem-solvability)
   - [Heuristic Algorithms](#heuristic-algorithms)
3. [Features](#features)
4. [Key Components](#key-components)
   - [Game State Expansion](#game-state-expansion)
   - [Priority Queue and A* Search](#priority-queue-and-a-search)
   - [Informed Search Strategies](#informed-search-strategies)
5. [How to Run](#how-to-run)
6. [Pseudocode](#pseudocode)
7. [Future Work](#future-work)
8. [Contributing](#contributing)

---

## Overview

The **8 Puzzle problem** consists of a 3x3 grid containing 8 numbered tiles and one blank space. The goal is to move the tiles to match a predefined "goal state" using the least number of moves. The problem's complexity stems from the large number of possible configurations (9!) and the requirement for an efficient solution.

This project employs **informed search strategies** using the following heuristics:
1. **Manhattan Distance**: Sum of the absolute differences between the current and target positions of tiles.
2. **Misplaced Tiles**: Count of tiles not in their goal positions.

---

## How It Works

### Understanding the 8 Puzzle

- **Initial State**: The starting arrangement of tiles, which can be user-defined or randomly generated.
- **Goal State**: The desired final arrangement of tiles.
- **Moves**: Tiles can move up, down, left, or right into the blank space.

### Problem Solvability

Not all 8 Puzzle configurations are solvable. The **solvability** of a given initial state is determined by the **number of inversions**:
- An **inversion** occurs when a larger numbered tile precedes a smaller one.
- A configuration is solvable if the number of inversions is even.

### Heuristic Algorithms

1. **Manhattan Distance**:
   - Calculates the total distance of all tiles from their target positions.
   - Formula:  
     \[
     f(x) = g(x) + h(x)
     \]  
     Where:
     - \(f(x)\): Total cost (path + heuristic)
     - \(g(x)\): Path cost (number of moves so far)
     - \(h(x)\): Manhattan distance (heuristic)

2. **Misplaced Tiles**:
   - Counts the number of tiles not in their goal positions.
   - Formula:  
     \[
     f(x) = h(x)
     \]

---

## Features

- **Two heuristic options**: Manhattan Distance and Misplaced Tiles.
- **Interactive input**: Users can provide custom initial states or generate random ones.
- **State validation**: Ensures solvability before proceeding.
- **Step-by-step solution**: Displays each move leading to the goal state.

---

## Key Components

### Game State Expansion

Each game state is treated as a **node** in a tree. From a given state:
- The possible child states are generated by moving the blank space in each valid direction.
- Each child state is evaluated using the selected heuristic.

### Priority Queue and A* Search

- The **priority queue** ensures nodes with the lowest cost (\(f(x)\)) are explored first.
- Nodes are added to the **open list** for exploration and moved to the **explored list** once visited.

### Informed Search Strategies

The project uses the **A*** algorithm, which combines:
1. **Path cost** (\(g(x)\)): Number of moves made so far.
2. **Heuristic value** (\(h(x)\)): Estimated cost to reach the goal.

---

## How to Run

### Requirements
- A C++ compiler (e.g., GCC).
- A terminal or IDE to run the program.

### Steps
1. **Compile the code**:
   ```bash
   g++ 8_Puzzle_Assignment.cpp -o 8_Puzzle_Solver
   ```
2. **Run the executable**:
   ```bash
   ./8_Puzzle_Solver
   ```
3. **Follow the prompts**:
   - Enter the initial board configuration manually or let the program generate a random one.
   - Choose the heuristic (Manhattan Distance or Misplaced Tiles).
4. View the solution and steps.

---

## Pseudocode

The following pseudocode outlines the **A*** search algorithm used in this project:

```plaintext
function AStarSearch(initial_state):
    open_list = PriorityQueue()
    explored_set = Set()
    
    open_list.insert(initial_state, priority=0)
    
    while not open_list.is_empty():
        current_node = open_list.extract_min()
        if current_node.is_goal():
            return reconstruct_path(current_node)
        
        explored_set.add(current_node)
        
        for each neighbor in current_node.generate_neighbors():
            if neighbor not in explored_set:
                neighbor_cost = current_node.g + 1  # Increment path cost
                neighbor_heuristic = calculate_heuristic(neighbor)
                neighbor.f = neighbor_cost + neighbor_heuristic
                
                if neighbor not in open_list:
                    open_list.insert(neighbor, neighbor.f)
    
    return failure
```

---

## Future Work

- **Enhanced GUI**: A graphical interface is partially implemented and can be extended for better visualization.
- **Support for Larger Grids**: Expanding the algorithm to handle larger puzzles (e.g., 15 Puzzle).
- **Performance Optimization**: Fine-tuning the heuristic calculations and data structures for faster execution.

---

## Contributing

Contributions are welcome! Feel free to open issues or submit pull requests for:
- Code improvements.
- Additional features.
- Documentation enhancements.
